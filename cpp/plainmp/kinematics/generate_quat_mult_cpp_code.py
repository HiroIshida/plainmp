from enum import Enum
from sympy import symbols, expand


def multiply_quaternions(q1, q2):
    w1, x1, y1, z1 = q1
    w2, x2, y2, z2 = q2
    w = w1*w2 - x1*x2 - y1*y2 - z1*z2
    x = w1*x2 + x1*w2 + y1*z2 - z1*y2
    y = w1*y2 - x1*z2 + y1*w2 + z1*x2
    z = w1*z2 + x1*y2 - y1*x2 + z1*w2
    return (expand(w), expand(x), expand(y), expand(z))


class RotAxis(Enum):
    NoRotation = "norot"
    X = "xaxis"
    Y = "yaxis"
    Z = "zaxis"
    General = "general"


def gen_symbolic_quaternion(variable_name: str, rot_axis: RotAxis):
    names = f"{variable_name}.w() {variable_name}.x() {variable_name}.y() {variable_name}.z()"
    w, x, y, z = symbols(names)
    if rot_axis == RotAxis.NoRotation:
        return (1, 0, 0, 0)
    if rot_axis == RotAxis.X:
        return (w, x, 0, 0)
    if rot_axis == RotAxis.Y:
        return (w, 0, y, 0)
    if rot_axis == RotAxis.Z:
        return (w, 0, 0, z)
    return (w, x, y, z)


def generate_impl_definition_code(rot_axis1: RotAxis, rot_axis2: RotAxis):
    q1 = gen_symbolic_quaternion("q_self", rot_axis1)
    q2 = gen_symbolic_quaternion("q_other", rot_axis2)
    result = multiply_quaternions(q1, q2)
    function_name = f"mult_quat_{rot_axis1.value}_{rot_axis2.value}"

    # NOTE: eigen's qutaernion's internal representation is (x, y, z, w)
    # although it is constructed from (w, x, y, z)
    cpp_source_code = ""
    cpp_source_code += "template <typename Scalar>\n"
    cpp_source_code += f"void {function_name}(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {{\n"
    cpp_source_code += f"  q_out.x() = {result[1]};\n".replace("*", " * ")
    cpp_source_code += f"  q_out.y() = {result[2]};\n".replace("*", " * ")
    cpp_source_code += f"  q_out.z() = {result[3]};\n".replace("*", " * ")
    cpp_source_code += f"  q_out.w() = {result[0]};\n".replace("*", " * ")
    cpp_source_code += "}\n"
    return cpp_source_code


def generate_header_signature_code(rot_axis1: RotAxis, rot_axis2: RotAxis):
    function_name = f"mult_quat_{rot_axis1.value}_{rot_axis2.value}"
    cpp_source_code = ""
    cpp_source_code += "template <typename Scalar>\n"
    cpp_source_code += f"void {function_name}(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out);\n"
    return cpp_source_code


def generate_impl_code():
    impl_code = """// this code is auto-generated by python script
/*
 * plainmp - library for fast motion planning
 *
 * Copyright (C) 2024 Hirokazu Ishida
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

// clang-format off
#include "plainmp/kinematics/quaternion_mult.hpp"

namespace plainmp::kinematics {

"""

    for self_rot_axis in [RotAxis.X, RotAxis.Y, RotAxis.Z, RotAxis.General]:
        for other_rot_axis in [RotAxis.NoRotation, RotAxis.X, RotAxis.Y, RotAxis.Z, RotAxis.General]:
            func_code = generate_impl_definition_code(self_rot_axis, other_rot_axis)
            impl_code += func_code
            impl_code += "\n"

    # closure of code using namespace kinematics
    impl_code += "\n"
    impl_code += "} // namespace plainmp::kinematics"
    impl_code += "// clang-format on"
    return impl_code


def generate_header_code():
    header_code = """// this code is auto-generated by python script
/*
 * plainmp - library for fast motion planning
 *
 * Copyright (C) 2024 Hirokazu Ishida
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

// clang-format off
#pragma once
#include <Eigen/Core>
#include <Eigen/Geometry>
namespace plainmp::kinematics {
"""
    for self_rot_axis in [RotAxis.X, RotAxis.Y, RotAxis.Z, RotAxis.General]:
        for other_rot_axis in [RotAxis.NoRotation, RotAxis.X, RotAxis.Y, RotAxis.Z, RotAxis.General]:
            header_code += generate_header_signature_code(self_rot_axis, other_rot_axis)
            header_code += "\n"
    header_code += "} // namespace plainmp::kinematics"
    header_code += "// clang-format on"
    return header_code


if __name__ == "__main__":
    header_code = generate_header_code()
    with open("_quaternion_mult.hpp", "w") as f:
        f.write(header_code)

    impl_code = generate_impl_code()
    with open("_quaternion_mult.cpp", "w") as f:
        f.write(impl_code)
