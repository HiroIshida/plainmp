// this code is auto-generated by python script
/*
 * plainmp - library for fast motion planning
 *
 * Copyright (C) 2024 Hirokazu Ishida
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

// clang-format off
#include "plainmp/kinematics/quaternion_mult.hpp"

namespace plainmp::kinematics {

template <typename Scalar>
void mult_quat_xaxis_norot(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_self.x();
  q_out.y() = 0;
  q_out.z() = 0;
  q_out.w() = q_self.w();
}

template <typename Scalar>
void mult_quat_xaxis_xaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x() + q_other.x() * q_self.w();
  q_out.y() = 0;
  q_out.z() = 0;
  q_out.w() = q_other.w() * q_self.w() - q_other.x() * q_self.x();
}

template <typename Scalar>
void mult_quat_xaxis_yaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x();
  q_out.y() = q_other.y() * q_self.w();
  q_out.z() = q_other.y() * q_self.x();
  q_out.w() = q_other.w() * q_self.w();
}

template <typename Scalar>
void mult_quat_xaxis_zaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x();
  q_out.y() = -q_other.z() * q_self.x();
  q_out.z() = q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w();
}

template <typename Scalar>
void mult_quat_xaxis_general(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x() + q_other.x() * q_self.w();
  q_out.y() = q_other.y() * q_self.w() - q_other.z() * q_self.x();
  q_out.z() = q_other.y() * q_self.x() + q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w() - q_other.x() * q_self.x();
}

template <typename Scalar>
void mult_quat_yaxis_norot(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = 0;
  q_out.y() = q_self.y();
  q_out.z() = 0;
  q_out.w() = q_self.w();
}

template <typename Scalar>
void mult_quat_yaxis_xaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.x() * q_self.w();
  q_out.y() = q_other.w() * q_self.y();
  q_out.z() = -q_other.x() * q_self.y();
  q_out.w() = q_other.w() * q_self.w();
}

template <typename Scalar>
void mult_quat_yaxis_yaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = 0;
  q_out.y() = q_other.w() * q_self.y() + q_other.y() * q_self.w();
  q_out.z() = 0;
  q_out.w() = q_other.w() * q_self.w() - q_other.y() * q_self.y();
}

template <typename Scalar>
void mult_quat_yaxis_zaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.z() * q_self.y();
  q_out.y() = q_other.w() * q_self.y();
  q_out.z() = q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w();
}

template <typename Scalar>
void mult_quat_yaxis_general(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.x() * q_self.w() + q_other.z() * q_self.y();
  q_out.y() = q_other.w() * q_self.y() + q_other.y() * q_self.w();
  q_out.z() = -q_other.x() * q_self.y() + q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w() - q_other.y() * q_self.y();
}

template <typename Scalar>
void mult_quat_zaxis_norot(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = 0;
  q_out.y() = 0;
  q_out.z() = q_self.z();
  q_out.w() = q_self.w();
}

template <typename Scalar>
void mult_quat_zaxis_xaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.x() * q_self.w();
  q_out.y() = q_other.x() * q_self.z();
  q_out.z() = q_other.w() * q_self.z();
  q_out.w() = q_other.w() * q_self.w();
}

template <typename Scalar>
void mult_quat_zaxis_yaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = -q_other.y() * q_self.z();
  q_out.y() = q_other.y() * q_self.w();
  q_out.z() = q_other.w() * q_self.z();
  q_out.w() = q_other.w() * q_self.w();
}

template <typename Scalar>
void mult_quat_zaxis_zaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = 0;
  q_out.y() = 0;
  q_out.z() = q_other.w() * q_self.z() + q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w() - q_other.z() * q_self.z();
}

template <typename Scalar>
void mult_quat_zaxis_general(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.x() * q_self.w() - q_other.y() * q_self.z();
  q_out.y() = q_other.x() * q_self.z() + q_other.y() * q_self.w();
  q_out.z() = q_other.w() * q_self.z() + q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w() - q_other.z() * q_self.z();
}

template <typename Scalar>
void mult_quat_general_norot(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_self.x();
  q_out.y() = q_self.y();
  q_out.z() = q_self.z();
  q_out.w() = q_self.w();
}

template <typename Scalar>
void mult_quat_general_xaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x() + q_other.x() * q_self.w();
  q_out.y() = q_other.w() * q_self.y() + q_other.x() * q_self.z();
  q_out.z() = q_other.w() * q_self.z() - q_other.x() * q_self.y();
  q_out.w() = q_other.w() * q_self.w() - q_other.x() * q_self.x();
}

template <typename Scalar>
void mult_quat_general_yaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x() - q_other.y() * q_self.z();
  q_out.y() = q_other.w() * q_self.y() + q_other.y() * q_self.w();
  q_out.z() = q_other.w() * q_self.z() + q_other.y() * q_self.x();
  q_out.w() = q_other.w() * q_self.w() - q_other.y() * q_self.y();
}

template <typename Scalar>
void mult_quat_general_zaxis(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x() + q_other.z() * q_self.y();
  q_out.y() = q_other.w() * q_self.y() - q_other.z() * q_self.x();
  q_out.z() = q_other.w() * q_self.z() + q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w() - q_other.z() * q_self.z();
}

template <typename Scalar>
void mult_quat_general_general(const Eigen::Quaternion<Scalar>& q_self, const Eigen::Quaternion<Scalar>& q_other, Eigen::Quaternion<Scalar>& q_out) {
  q_out.x() = q_other.w() * q_self.x() + q_other.x() * q_self.w() - q_other.y() * q_self.z() + q_other.z() * q_self.y();
  q_out.y() = q_other.w() * q_self.y() + q_other.x() * q_self.z() + q_other.y() * q_self.w() - q_other.z() * q_self.x();
  q_out.z() = q_other.w() * q_self.z() - q_other.x() * q_self.y() + q_other.y() * q_self.x() + q_other.z() * q_self.w();
  q_out.w() = q_other.w() * q_self.w() - q_other.x() * q_self.x() - q_other.y() * q_self.y() - q_other.z() * q_self.z();
}


} // namespace plainmp::kinematics// clang-format on